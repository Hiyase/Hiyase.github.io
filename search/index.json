[{"content":"前言 我见过好多人文件管理规则并不规范，虽然规范是人定义的，但是如果你按照我说的去管理，实际上你会舒服很多，会让你想要找的东西更好找，而不是在一堆垃圾堆里去翻找（一种形容）\n管理方法 磁盘分区 我的习惯分为三份，同时我也建议这么分区，另外如果你熟练了我这种习惯,你也可以这么分\n这里假设你的硬盘比较小，你有一个 128GB 的固态硬盘 一个1T的机械硬盘\n我的建议是单独128G硬盘作为系统，1T机械盘分为两个区，一个游戏，一个程序\n如果你不打游戏，用作游戏的分区用来放各类源码，或者是文档，也是好的\n文件管理 首先，我是在假设你的系统盘比较小的情况，进行管理的，所以不会放太多东西\n这样做也会让你一眼看过去就知道是什么，我希望你刚刚安装完的系统，而不是混乱的\nC盘(系统盘)的管理 1 2 3 4 5 C:\\ ├──Program Files #程序目录 ├──Program Files (x86) #程序目录(32位程序) ├──Windows #系统目录 └──Users #用户目录 以上是在未显示隐藏文件的情况下，默认有四个文件夹，最好的管理就是不加任何东西\n大多程序都默认装在 C:\\Program Files (x86)\\里面的原因，就是因为它是程序目录 所以实际上在这很合理，如果要更改目录，也建议更改最前面的卷标 C:\\ 到 E:\\ 这样操作\nD盘的(游戏/代码盘)管理 以下是假设你的盘是游戏盘，文件如此规划\n如果是程序盘\u0026hellip;自己开心就好\n1 2 3 4 5 D:\\ ├──SteamLibrary #Steam的游戏目录，你可以手动设置在这 └──* 你可以把任意平台的游戏都单独建立一个文件夹，这是个好习惯 由于它会是第一个分区，即便是机械盘，理论性能效率也会稍微好一点点点点.... 这里不是重点，重点是下面\nE盘(程序/杂项盘)的管理 这里就是整篇文章的重点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 E:\\ ├──Program Files #程序目录(在这有一份，方便你把程序放在这) │ ├──Clash for Windows │ ├──Notepad3 #高级记事本 │ ├──Steam #嗯... │ ├──VSCode #代码编辑器、高级记事本（浏览器(确信) │ └──... ├──Program Files (x86) #程序目录(32位程序,也可以不建立/使用,但建议) │ ├──Tencent #腾讯家的程序(QQ/微信放里) │ └──... └──UserData #用户数据文件夹 ├──Desktop #桌面，这样不用担心桌面被塞满 ├──Documents #文档，微信和QQ都会把数据存到文档,减少C盘占用 ├──Downloads #下载，下载的东西都放这边,也可以建下级目录 └──... #图片/视频之类你任何想放这里的 另外提一个我自己的小习惯\n所有在 E:\\Program..\\下的所有程序，我都会习惯性的给程序的文件夹设置上图标\n最后 说实话，我非常建议每个人都这么有序的放置文件，和程序，即便你不习惯\n因为你能很快的找到目录，不必担心有什么东西找不到\n","date":"2023-10-08T00:00:00Z","permalink":"https://hiyase.github.io/p/how-to-manager-your-windows-files/","title":"Windows文件管理哲学"},{"content":"硬件 对于通常PC来讲，当你第一次开机时(相对于固件程序)，硬件会完成一遍通体自检\n检查CPU，内存，硬盘，显卡(有顺序，但不知道)等硬件\n等待自检完成后进行下一步启动\n一个基础知识：无论是UEFI，还是BIOS，都是一种固件程序\n单UEFI的实现甚至可以没有BIOS控制\nBIOS 当BIOS启动时，BIOS首先会检查一遍(或三遍)硬件(主板本身，CPU，内存，显卡)，然后初始化硬件信息和各类设备(存储，其他外设等)\n然后寻找各个储存设备的MBR(主引导记录)部分，然后启动(后面更多算软件了，懒得讲)\nUEFI 在大多数UEFI固件启动过程中，并不会做过多的硬件检测，而是给系统进行检测，并且有一套相对统一的接口\nFast Boot（快速启动） UEFI的快速启动功能，一般不会在第一次启动时出现\n硬件部分的快速启动一般是指，只初始化部分硬件，例如，只初始化你上次启动的硬盘，和上次有通讯的鼠标，键盘等接口，直接不初始化PS/2等接口\n这里我印象里更多是延迟初始化硬件，它可以进入系统后，或者过程中初始化信息，这些我并不确定\nNVRAM NVRAM是指UEFI固件启动顺序的存储区(可能包括存储设置信息)，这里存储的信息有：启动顺序，启动项名称，启动项指向的硬盘及启动的EFI文件\n当系统安装进硬盘的最后时刻，一般会添加NVRAM信息，Linux系统使用efibootmgr进行管理，Windows使用bcdedit进行管理\n当然，也可能包含其他我并不知道的信息，但主要信息就是这些\nBoot （启动） UEFI的启动，照常理来说，会优先检索NVRAM进行启动，如果NVRAM没有\n则会检测所有存储设备的GPT分区格式，寻找EFI分区\n默认启动里面的/EFI/Boot/bootx64.efi 如果没有该文件，应该默认找该目录的bootia32.efi\n无论是bootx64还是bootia32，都只应该是一个指路牌\n部分固件程序会设计不寻找bootia32，也有部分会直接检索EFI/目录下的所有efi文件进行NVRAM的添加，但这应该并不是标准操作\nSecure Boot（安全启动） 在安全启动启用的情况，启动EFI的过程中，会校验EFI存在的签名信息，它是否已经内置在了固件中，如没有内置，就直接禁止启动\n在大多数Android设备上，Bootloader锁，就是一种安全启动的行为，但是里面只包含了设备制造商的签名信息\n另外，签名信息是可以自签名并且导入进固件中的。\n当然，这种情况也适用于Android，但是方法可能不一样，但理论是相同的\n","date":"2023-09-21T00:00:00Z","permalink":"https://hiyase.github.io/p/computer-startup-process/","title":"计算机启动过程"},{"content":"以下信息获取方法都是在设备 Redmi K30 Pro 以及 Crdroid Rom 上进行\n如在联发科，华为设备上，可能部分命令无法使用。且不保证所有命令都可以使用\nADB Base command 1 2 3 adb -s [serial/IP:Port] #使用指定的序列号/地址进行连接 adb devices -l #获取已连接的设备， -l 有更细节的参数 adb connect #ip:port 通过无线网络连接 state: authorizing (等待授权) ，device(已连接) no device(无设备) ，offline(未连接/无响应)\n1 2 3 4 5 6 usb: #有此参数表示该设备通过USB连接 product: lineage_lmi #设备的产品名称是lineage_lmi，它似乎运行的是LineageOS自定义ROM。 model: Redmi_K30_Pro #设备的模型名称是Redmi K30 Pro。 device: lmi #设备的代号 transport_id: 11 #传输ID为11 #由以下三个属性组成：ro.product.name ro.product.model ro.product.device https://www.cnblogs.com/1996swg/p/9810424.html 要看一下\nGet Hardware info 1 2 3 4 5 adb shell getprop ro.product.manufacturer #获取设备制造商 adb shell getprop ro.product.model #获取设备型号 adb shell getprop ro.product.name #获取设备产品名称 adb shell getprop ro.product.device #获取设备代号 adb shell getprop ro.product.board #获取主板型号 CPU info 1 2 3 4 5 6 7 8 9 10 adb shell getprop ro.soc.manufacturer #获取soc制造商 adb shell getprop ro.soc.model #获取soc名称 adb shell cat /sys/devices/soc0/vendor #获取soc0的制造商信息 adb shell cat /sys/devices/soc0/family #获取soc0的家族系列 adb shell cat /sys/devices/soc0/chip_name #获取soc0的芯片名称 adb shell cat /sys/devices/system/cpu/possible #获取 cpu 核心数 adb shell cat /proc/stat #获取 cpu 运行状态 adb shell cat /proc/cpuinfo adb shell su -c cat \u0026#39;/dev/block/bootdevice/by-name/logfs | grep \u0026#34;Chip\u0026#34;\u0026#39; #芯片，版本，序列号（疑似联发科不可用） processor: 0/1 表示第几个核。 BogoMIPS：伪MIPS，用于测量CPU速度 Features：表示当前CPU所支持的特性 CPU architecture：7表示arm-v7，8表示arm-v8\nMore CPU info 1 adb shell cat /sys/devices/system/cpu/cpufreq/policy[id]/ affected_cpus — 这一组policy可调度哪个核心 cpuinfo_min_freq — CPU 最小可用频率 cpuinfo_max_freq — CPU 最大可用频率 scaling_driver — CPUfreq 的驱动程序 scaling_available_governors — 列出CPU可用的调度器 scaling_available_frequencies — 列出CPU的可用频率 scaling_governor — 正在使用的CPUfreq调度器 (可更改) cpuinfo_cur_freq — 显示 CPU 当前的处理频率 scaling_min_freq — 当前最小频率 (可更改) scaling_max_freq — 当前最大频率 (可更改) 使用 echo [调度器] \u0026gt; /sys/devices/system/cpu/cpufreq/policy[id]/scaling_governor (root)可以更改调度器 频率同理，但无论更改哪个，必须是可用的\n1 adb shell \u0026#39;su -c \u0026#34;echo xxx \u0026gt; file\u0026#34;\u0026#39; possible 可能的CPU核心数 present 展示的CPU核心数 modalias ：CPU 类型和 feature uevent :展示(?)信息 (需要Root) 作用不详 ofline online 下线/上线的CPU\nGet GPU info 1 2 3 4 adb shell dumpsys gfxinfo #信息过多需要精简(无用信息) adb shell dumpsys graphicsstats #应用显卡占用历史信息(无用信息) adb shell dumpsys SurfaceFlinger |grep GLES #显卡型号及OpenGL版本 adb shell cmd gpu vkjson # vulkan 信息(部分)(未来可能弃用) 在 /sys/kernel/gpu 目录下，可以修改调度器及频率信息(更改和读取均需要Root) 华为设备可能不在此目录\ngpu_available_governor — 可用的调度器列表 gpu_governor — 当前使用的调度器 (可更改) gpu_freq_table — 支持频率列表 gpu_min_clock — 当前最小频率 (可更改) gpu_max_clock — 当前最大频率 (可更改) gpu_busy — 当前占用率 gpu_clock — 当前处理频率，单位Mhz gpu_tmu — 不知道 上述目录是软链接，真实目录为： /sys/devices/platform/soc/3d00000.qcom,kgsl-3d0/devfreq/3d00000.qcom,kgsl-3d0 但使用真实目录可能会造成不兼容\nOpenGL和Vulkan的更多信息只能通过代码实现 from Google: 如果设备包含 Vulkan 驱动程序，则该设备需要声明 FEATURE_VULKAN_HARDWARE_LEVEL 和 FEATURE_VULKAN_HARDWARE_VERSION 系统功能\nGet Memory info 1 2 3 4 adb shell cat /proc/meminfo #参数太多，等待理解 adb shell dumpsys procstats #内存占用情况，等待检查更多参数 adb shell dumpsys meminfo -h #等待检查更多参数 adb shell su -c cat \u0026#39;/dev/block/bootdevice/by-name/logfs | grep \u0026#34;DDR Frequency\u0026#34;\u0026#39; #疑似获取内存频率 (疑似联发科不可用) Get Disk info 1 2 3 adb shell dumpsys diskstats #磁盘状态 adb shell df #目前信息还少，需要其他方案 adb shell dd \u0026#34;if=/dev/block/bootdevice/by-name/recovery of=/sdcard/recovery.img\u0026#34; #备份recovery 到 /sdcard Get Screen info 1 2 3 adb shell dumpsys display #大量显示相关信息 (需筛选) adb shell dumpsys SurfaceFlinger #图形合成器信息（包含屏幕信息，等筛选 adb shell getprop ro.sf.lcd_density #疑似获取默认屏幕密度 wm Command 1 2 3 4 adb shell wm size #显示或更改尺寸 adb shell wm size reset #重置屏幕尺寸 adb shell wm density #显示或更改密度 adb shell wm density reset #重置屏幕密度 Get Battery info 1 2 adb shell dumpsys battery -h #等待检查更多参数 adb shell dumpsys batterystats -h #等待检查更多参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 From adb shell dumpsys battery AC powered: true #表示交流电充电 true为正在充电,false为未在充电 USB powered: false #表示USB充电，规则同上，省略 Wireless powered: false #表示无线充电 Max charging current: 1742674 #当前充电电流， 这里为 1742674 µA 微安培 换算为 1742.674 mA Max charging voltage: 4289539 #当前充电电压， 这里为 4289539 nV 纳伏特 换算为 4.289539 mV Charge counter: 2015801 #疑似单位为 µAh 微安时 换算为 2015.801mAh 充满电时为 3622.000mAh 可能是损耗 status: 2 #电池状态 1: 未知 2: 正在充电 3: 正在放电 4: (已连接)但未充电 5:已充满 health: 2 #电池健康 1: 未知 2: 良好 3: 过热 4: 已损坏 5: 电压过高。6: 未知故障。7: 温度过低 present: true #true表示已安装电池 level: 56 ##当前电池电量 scale: 100 ##最大电池电量 voltage: 4289 #电池电压 temperature: 307 #温度，这里是30.7°C technology: Li-poly #电池技术，这里是锂电池 设计电池电量需要实用代码实现，充电信息可能只能使用Root获取 Use root Get Battery info 1 2 3 adb shell su -c cat /sys/class/power_supply/bms/uevent adb shell su -c cat /sys/class/power_supply/battery/uevent adb shell su -c cat /sys/class/power_supply/usb/uevent Get Camera info 1 adb shell dumpsys media.camera #等待信息筛选 更多信息需要代码实现\nGet Network info 1 2 3 4 adb shell ifconfig #可以使用 adb shell dumpsys wifi #大量无用信息，懒得筛选 adb shell dumpsys telecom #可能有相关信息 adb shell dumpsys telephony.registry #可能有相关信息 目前无进度，使用代码实现，使用root可以使用iw命令() Get Bluetooth info 1 adb shell dumpsys bluetooth_manager #一条命令基本足以 Get Audio info 1 adb shell dumpsys media.audio_policy Get OtherDevice info 1 2 adb shell dumpsys input #输入设备 adb shell dumpsys sensorservice #传感器 Get System info 1 adb shell pm list features #系统所支持的特性 Get Build info 1 2 3 4 5 6 7 8 9 10 11 adb shell getprop ro.build.version.release # Android 版本号 adb shell getprop ro.build.version.sdk # API 版本 adb shell getprop ro.build.version.security_patch # 安全更新的日期 adb shell getprop ro.build.id # 构建的版本号 adb shell getprop ro.build.display.id # 显示的构建版本号 adb shell getprop ro.build.fingerprint # 构建的指纹 adb shell getprop ro.build.date # 构建时间 adb shell getprop ro.build.date.utc # 以unix时间戳显示的构建时间 adb shell getprop ro.build.tags # 构建的标签 adb shell getprop gsm.version.baseband # 获取基带信息 adb shell uname -a # 获取内核版本 Get permission info 1 2 adb shell pm list permission-groups #列出所有权限组 adb shell pm list permissions #列出所有权限 Get Users info 1 2 3 4 5 6 7 8 adb shell pm list users #列出所有用户 adb shell pm create-user #创建用户 adb shell pm remove-user #删除用户 adb shell pm get-max-users #获取最大用户数 adb shell setprop fw.max_users 10 #设置最大用户数为10 (需要root) adb shell pm set-user-restriction #设置用户限制 adb shell pm get-max-running-users #获取系统可以运行的最大用户数 adb shell dumpsys activity users #活动中的用户信息 Get Other info 1 2 3 4 adb shell dumpsys media.player # 编解码器信息 adb shell dumpsys media.extractor # 编解码器信息 adb shell dumpsys account # 获取用户下已登陆账户信息 adb shell dumpsys webviewupdate #WebView信息 Settings 当命令是setings get 为获取 put 为修改 使用 setprop 可以更改prop内容\n1 2 3 4 5 adb shell getprop persist.sys.locale # 设置的语言 adb shell getprop persist.sys.timezone # 设置的时区 adb shell settings get secure system_locales # 系统的语言地区信息(?) adb shell settings get global device_name # 用户定义的设备名称 adb shell settings get global zram_enabled # 是否启用zram Captive Protal 网络验证功能 修改后需要重启网络\n1 2 3 4 5 adb shell settings get global captive_portal_detection_enabled # 1为启用 0为禁用 adb shell settings get global captive_portal_use_https # 是否启用https adb shell settings get global captive_portal_server # 验证服务地址 adb shell settings get global captive_portal_http_url adb shell settings get global captive_portal_https_url ","date":"2023-08-19T00:00:00Z","permalink":"https://hiyase.github.io/p/use-adb-get-info/","title":"使用ADB获取各类信息"},{"content":"扪心自问，我真的懂程序吗… 从21年，甚至更早，想着自己写一个项目，但到目前为止，内心的项目到现在仍未实现，本来想着第一篇博客是一个技术向博客，但是还是在这里碎碎念吧…\n在VSCode面前，放在键盘上，试想着如何写出，试想着搜索什么，左右拼凑成一个我自己写出来的项目程序，可是没学过任何程序的我…不会写甚至于…内心充满了悲伤，我很痛苦，很想写出来做一个优秀漂亮的好程序，大项目，可是连开头我都做不出来，甚至想用ChatGPT帮我写，有着思路，有着头绪的输入，但是总好像不完美，我不够满意……我……好像不懂程序，但我总是试着理解程序…例如一次点击事件，一次鼠标的拖动事件(其XY坐标的变化…)。\n让程序只是能跑起来？…嗯…我不满意…是这样，我不想妥协…想让程序更高效，更优质，而不只是，it work。\nAndroidManager程序规划 都写到这里了，讲一讲心里那个程序规划吧，有人要是愿意抄出来呢，也好，但是请写思路来源这里，接下来讲大致的程序设计吧\n一个基于ADB(Android Debug Bridge)的 桌面端的 Android管理器 可能也会用到Fastboot之类的Android-Platform-Tools，我想做的功能有很多，也想开源。说实话，我觉得它更像一个手机助手 但我希望它是一个跨平台的，支持多设备的，支持各类语言的Android管理器\n设备信息获取(主页面)： ADB的权限很高，可以拿到很多设备信息，让人知道自己的硬件状况，拿不到的就用Root做 获取处理器，内存，硬盘，屏幕，电池，摄像头，甚至是指纹和扬声器的信息，用户有权知道硬件是谁制造的，有着什么参数 然后就是获取系统信息，是否Root，SELinux状态，甚至是SafeNet，虽然没什么用，不放会觉得缺点什么(也不着重写) 主页面套个 scrcpy作为屏幕显示和控制（也作为一个主功能） 应用管理器(模块)： 可以进行多用户管理的应用管理器,可以进行多用户管理的应用管理器,可以进行多用户管理的应用管理器(对多用户功能的执念) 嗯\u0026hellip;对应用的安装，卸载，备份，显示应用的各类信息，对活动，服务，权限(AppOps)的管理 文件管理器(模块)： 走MTP服务的文件管理器效率好像很慢，所以基于ADB的来一份效率会不会提高(所以只是普通的文件管理器) 如果adb效率不高的话，就在设备上开文件相关的网络服务(如FTP/SMB) 任务管理器(模块)： 以Android应用管理视角和Linux进程管理视角做主选项，显示CPU，内存，硬盘读写占用情况，显示哪个用户使用 按CPU、内存、硬盘、占用情况及用户排序，显示其应用下的服务/进程，或是进程下的进程，并且给折叠起来 CPU(多线程)、内存(硬件保留，系统占用，应用占用，已缓存)、硬盘独立的占用视图及相关详细数据 以及进程状态，甚至是给设置状态（如ACTIVE,RARE等（好像应该放在应用管理器） 磁盘管理器(模块)： 对Android所有分区进行备份，还原，格式化，擦除，对分区进行调整(危险性功能警告) 挂载内存盘 杂项功能(模块)： 大概就是一些改一些设置页面不存在的隐藏设置，例如改一改网络检测服务器，改一改时间更新服务器 还有就是围绕着ADB的各类东西，黑域激活，冰箱激活那种吧 既然要画饼，那就画大饼，哪怕吃不下 后续随时可能修改文章，把饼画的更大\nscrcpy题外话：在scrpy开发者的博客里,有把dex文件push进系统里的方法，一些功能无法实现的话，也可以试试\n","date":"2023-08-07T00:00:00Z","permalink":"https://hiyase.github.io/p/my-programs-question/","title":"我真的懂程序吗"},{"content":"Welcome to Hugo theme Stack. This is your first post. Edit or delete it, then start writing!\nFor more information about this theme, check the documentation: https://docs.stack.jimmycai.com/\nWant a site like this? Check out hugo-theme-stack-stater\nPhoto by Pawel Czerwinski on Unsplash\n","date":"2022-03-06T00:00:00Z","image":"https://hiyase.github.io/p/hello-world/cover_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://hiyase.github.io/p/hello-world/","title":"Hello World"}]